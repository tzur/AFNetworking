// Copyright (c) 2014 Lightricks. All rights reserved.
// Created by Yaron Inger.

#import "LTEAWProcessor.h"

#import "LTColorConversionProcessor.h"
#import "LTGPUImageProcessor+Protected.h"
#import "LTPyramidProcessor.h"
#import "LTShaderStorage+LTBlueYellowEAWProcessorFsh.h"
#import "LTShaderStorage+LTBlueYellowEAWProcessorVsh.h"
#import "LTShaderStorage+LTRedBlackEAWProcessorFsh.h"
#import "LTShaderStorage+LTRedBlackEAWProcessorVsh.h"
#import "LTTexture+Factory.h"

#pragma mark -
#pragma mark LTEAWBlueYellowProcessor
#pragma mark -

/// Drives the blue-yellow EAW filtering stage.
@interface LTEAWBlueYellowProcessor : LTOneShotImageProcessor

/// Initializes with an original texture (pre previous-stage filtering), an input texture and an
/// output texture.
- (instancetype)initWithOriginal:(LTTexture *)original input:(LTTexture *)input
                          output:(LTTexture *)output;

/// Compression factor defined by the user.
@property (nonatomic) LTVector4 compressionFactor;

@end

@implementation LTEAWBlueYellowProcessor

- (instancetype)initWithOriginal:(LTTexture *)original input:(LTTexture *)input
                          output:(LTTexture *)output {
  if (self = [super initWithVertexSource:[LTBlueYellowEAWProcessorVsh source]
                          fragmentSource:[LTBlueYellowEAWProcessorFsh source]
                           sourceTexture:original
                       auxiliaryTextures:@{[LTBlueYellowEAWProcessorFsh currentLevelTexture]: input}
                               andOutput:output]) {
    self[[LTBlueYellowEAWProcessorVsh texelOffset]] = $(LTVector2(1 / input.size.width,
                                                                  1 / input.size.height));
    self[[LTBlueYellowEAWProcessorFsh textureSize]] = $(LTVector2(input.size));
  }
  return self;
}

- (void)setCompressionFactor:(LTVector4)compressionFactor {
  _compressionFactor = compressionFactor;
  self[[LTBlueYellowEAWProcessorFsh compressionFactor]] = $(compressionFactor);
}

@end

#pragma mark -
#pragma mark LTEAWRedBlackProcessor
#pragma mark -

/// Drives the red-black EAW filtering stage.
@interface LTEAWRedBlackProcessor : LTOneShotImageProcessor

/// Initializes with an original texture (pre previous-stage filtering), an input texture and an
/// output texture.
- (instancetype)initWithOriginal:(LTTexture *)original input:(LTTexture *)input
                          output:(LTTexture *)output;

/// Compression factor defined by the user.
@property (nonatomic) LTVector4 compressionFactor;

@end

@implementation LTEAWRedBlackProcessor

- (instancetype)initWithOriginal:(LTTexture *)original input:(LTTexture *)input
                          output:(LTTexture *)output {
  if (self = [super initWithVertexSource:[LTRedBlackEAWProcessorVsh source]
                          fragmentSource:[LTRedBlackEAWProcessorFsh source]
                           sourceTexture:original
                       auxiliaryTextures:@{[LTRedBlackEAWProcessorFsh currentLevelTexture]: input}
                               andOutput:output]) {
    self[[LTRedBlackEAWProcessorVsh texelOffset]] = $(LTVector2(1 / input.size.width,
                                                                1 / input.size.height));

    self[[LTRedBlackEAWProcessorFsh inputTextureSize]] = $(LTVector2(input.size));
    self[[LTRedBlackEAWProcessorFsh outputTextureSize]] = $(LTVector2(output.size));

    if (input.size == output.size) {
      self[[LTRedBlackEAWProcessorVsh texelScaling]] = $(LTVector2(1));
      self[[LTRedBlackEAWProcessorFsh sameSize]] = @(YES);
    } else {
      self[[LTRedBlackEAWProcessorVsh texelScaling]] = $(LTVector2(output.size / (2 * input.size)));
      self[[LTRedBlackEAWProcessorFsh sameSize]] = @(NO);
    }
  }
  return self;
}

- (void)setCompressionFactor:(LTVector4)compressionFactor {
  _compressionFactor = compressionFactor;
  self[[LTRedBlackEAWProcessorFsh compressionFactor]] = $(compressionFactor);
}

@end

#pragma mark -
#pragma mark LTEAWProcessor
#pragma mark -

@interface LTEAWProcessor ()

/// Converter from RGB to luminance.
@property (strong, nonatomic) LTColorConversionProcessor *conversionProcessor;

/// Pyramid processor used to create the image pyramid with NN interpolation.
@property (strong, nonatomic) LTPyramidProcessor *pyramidProcessor;

/// Array of \c LTTexture objects holding the pyramid levels. Level 0 contains the input image, and
/// levels [1..] are generated by the pyramid processor.
@property (strong, nonatomic) NSArray *levels;

/// Output texture of this processor.
@property (strong, nonatomic) LTTexture *outputTexture;

@end

@implementation LTEAWProcessor

- (instancetype)initWithInput:(LTTexture *)input output:(LTTexture *)output {
  if (self = [super init]) {
    self.outputTexture = output;

    LTTexture *luminance = [LTTexture textureWithPropertiesOf:output];
    [self createConversionProcessorWithInput:input output:luminance];
    [self createPyramidProcessorWithLuminanceTexture:luminance];

    self.compressionFactor = LTVector4(1);
  }
  return self;
}

- (void)createConversionProcessorWithInput:(LTTexture *)input output:(LTTexture *)output {
  self.conversionProcessor = [[LTColorConversionProcessor alloc]
                              initWithInput:input output:output];
  self.conversionProcessor.mode = LTColorConversionRGBToYYYY;
}

- (void)createPyramidProcessorWithLuminanceTexture:(LTTexture *)luminance {
  NSArray *pyramidLevels = [LTPyramidProcessor levelsForInput:luminance];
  self.levels = [@[luminance] arrayByAddingObjectsFromArray:pyramidLevels];
  self.pyramidProcessor = [[LTPyramidProcessor alloc] initWithInput:luminance
                                                            outputs:pyramidLevels];
}

- (void)setLevels:(NSArray *)levels {
  _levels = levels;
  
  for (LTTexture *level in levels) {
    [self applyNearestInterpolation:level];
  }
}

- (void)preprocess {
  [self.conversionProcessor process];

  [self.pyramidProcessor.inputTexture executeAndPreserveParameters:^{
    [self applyNearestInterpolation:self.pyramidProcessor.inputTexture];
    [self.pyramidProcessor process];
  }];
}

- (void)process {
  [self preprocess];

  LTTexture *nextLevelOriginal = self.levels[self.levels.count - 2];

  for (NSInteger i = self.levels.count - 2; i >= 0; --i) {
    @autoreleasepool {
      LTTexture *currentOriginal = nextLevelOriginal;

      if (i > 0) {
        nextLevelOriginal = [self.levels[i - 1] clone];
        [self applyNearestInterpolation:nextLevelOriginal];
      }

      [self processLevel:i original:currentOriginal];
    }
  }

  [self.levels[0] cloneTo:self.outputTexture];
}

- (void)processLevel:(NSUInteger)level original:(LTTexture *)original {
  LTTexture *yellowBlueOutput = [LTTexture textureWithPropertiesOf:self.levels[level]];
  [self applyNearestInterpolation:yellowBlueOutput];

  LTEAWBlueYellowProcessor *blueYellow = [[LTEAWBlueYellowProcessor alloc]
                                          initWithOriginal:original input:self.levels[level]
                                          output:yellowBlueOutput];
  blueYellow.compressionFactor = [self compressionFactorForLevel:level];
  [blueYellow process];

  // For the top level, the same texture will be the output. It's the red-black processor
  // responsibility to handle this end case.
  LTEAWRedBlackProcessor *redBlack = [[LTEAWRedBlackProcessor alloc]
                                      initWithOriginal:original input:yellowBlueOutput
                                      output:self.levels[MAX((NSInteger)level - 1, 0L)]];
  redBlack.compressionFactor = [self compressionFactorForLevel:level];
  [redBlack process];
}

- (void)applyNearestInterpolation:(LTTexture *)texture {
  texture.minFilterInterpolation = LTTextureInterpolationNearest;
  texture.magFilterInterpolation = LTTextureInterpolationNearest;
}

- (LTVector4)compressionFactorForLevel:(NSUInteger)level {
  return LTVector4(std::pow(self.compressionFactor.x, self.levels.count - 2 - level),
                   std::pow(self.compressionFactor.y, self.levels.count - 2 - level),
                   std::pow(self.compressionFactor.z, self.levels.count - 2 - level),
                   std::pow(self.compressionFactor.w, self.levels.count - 2 - level));
}

@end
